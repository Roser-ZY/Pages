---
title: "Normal Texture"
author: "Roser"
date: 2025-05-08
image: "images/content/OpenGL.png"
draft: false
tags:
  - OpenGL
  - Review
  - Texture
  - Lighting
sr-due: 2025-05-12
sr-interval: 28
sr-ease: 250
draft: false
---
[纹理贴图](../纹理贴图.md)实现了平面的拟真，让平面看上去更真实，但是仔细看仍然能看出这只是一个平面，但现实中物体表面通常是凹凸不平的。想让光线呈现更真实的光照效果，就需要法线贴图。

以砖墙距离，虽然贴图能够让墙体看上去存在缝隙和小洞，但是真正放在光源下，能够看出这些缝隙和小洞并没有在计算光照模型时考虑进去。因为在片段着色器中我们没有信息对贴图哪部分需要进行额外处理。

想要实现光线对一些细节展现出更立体的效果（虽然本质上还是平面），可以采用法线贴图来实现。法线贴图可以为光照系统提供一些信息，用来实现一些立体效果。

细想一下，如何避免平面看起来不是完全平的平面？关键就是表面的法向量。

![](images/法向量映射的表面示意图.png)

下图是使用法线贴图后的墙面。

![](images/法线贴图对比.png)

法线贴图的 `x,y,z` 可以借助 `r, g, b` 来存储。可通过计算将 `[-1, 1]` 转换到 `[0, 1]` 以用 `r, g, b` 存储，后面反向运算即可恢复数据。

法线贴图的 `y` 轴通常是反向的，因为 OpenGL 读取时会将 `y` 轴反向。

> `y` 轴反向这个原因是因为我们的计算都是从左下角开始，但是屏幕坐标通常是从左上角开始。

在片段着色器中，对法线贴图进行计算并恢复数据到 `[-1, 1]`。

```c
uniform sampler2D normalMap;
void main() {
// obtain normal from normal map in range [0,1]
normal = texture(normalMap, fs_in.TexCoords).rgb;
// transform normal vector to range [-1,1] normal = normalize(normal * 2.0 - 1.0);

[...]

// proceed with lighting as normal
}
```

目前为止一切正常，但是目前的法线贴图中的坐标均是指向 `z` 轴的，如果我们将墙平躺在底面，则此时由于法向量依然指向 `z` 轴，会导致 光照计算出现问题。

![](images/法线贴图未进行坐标变换时产生的光照错误.png)

可以看到图片中的法向量依然指向 `z` 轴，而正确的方向应该是 `y` 轴。这个问题可以通过使用一个**不同的坐标空间**来计算光照，在不改动或新增法线贴图的情况下，让法线变换到 y 轴，从而实现正确的光照。

这个坐标空间称为[切向空间](../../Graphics/切向空间.md)（Tangent Space）。

> 借助切向空间，实际上可以正确转换任意方向的面。

有两种使用方法，一种是将切向空间的内容转换到世界空间，另一种是将世界空间的所有内容转换到切向空间。

> #Todo 后面可以在这里添加一下转换的代码实现。

第二种方式要进行更多的计算，包括矩阵乘法，看起来效率更低，但实际上，第二种方法有额外的优势。因为第二种方法我们可以在[顶点着色器](../Shader/顶点着色器.md)中进行计算。