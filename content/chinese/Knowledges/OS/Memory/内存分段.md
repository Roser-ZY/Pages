---
title: "内存分段"
author: "Roser"
date: 2025-04-08
image: "images/content/OS.png"
draft: false
tags:
  - OS
  - Review
  - Draft
sr-due: 2025-04-23
sr-interval: 15
sr-ease: 230
---
程序是由若干个逻辑分段组成，例如代码段、数据段、堆、栈等。不同的段具有不同的属性，因此可以用分段的形式将这些段分离出来。

分段机制下，虚拟地址分为两部分：段选择因子和段内偏移量。

![](../image/内存分段寻址逻辑.webp)

段选择因子保存在**段寄存器**内，段选择因子中有段号，用来在**段表**中进行索引。段表中存有该段的基地址、界限和特权等级等。

段内偏移量应该位于 0 和段界限之间，如果段内偏移是合法的，就将段基地址和段内偏移相加得到物理内存的地址。

> #Question 什么是段表？

内存分段会产生内存碎片问题和效率问题。
### 内存碎片问题

内存碎片分为外部碎片和内部碎片。

> 内部碎片是指在内存中无效的内存碎片，外部碎片是指内存中没有足够的连续内存供磁盘交换。

内存分段管理可以做到根据段的实际需求分配内存，不会产生内部内存碎片。

但由于每个段的长度不固定，多个段未必能恰好使用所有内存空间，会产生很多不连续的小物理内存，导致新的程序无法（从磁盘）被装载进物理内存。

解决外部内存碎片的问题就是**内存交换**（Swap）。例如有 1G 物理内存，用户执行了多个程序：
- 游戏占用 512MB；
- 浏览器占用 128MB；
- 音乐占用 256MB；

还剩下 128MB 的空闲内存，假如此时关闭浏览器，则一共有 256MB 空闲内存，但是浏览器占用的那部分和原本的空闲内存不连续（中间有个音乐程序），因此即使有 256MB 空闲内存，仍然无法再打开一个 200MB 左右的程序。

此时，可以通过交换，将音乐先写回硬盘，此时内存一共有 512MB 连续空闲内存。然后，再将音乐装载进内存，此时直接让音乐紧跟游戏占用的内存之后，这样最后会空出 256MB 的连续空闲内存，就可以继续打开一个 200MB 的程序。

> Linux 中看到的 Swap 控件就是从硬盘划分出来用于内存与硬盘空间交换的部分。

如果内存交换非常频繁，每次与硬盘进行内存交换是非常耗时的（硬盘读写与内存相比非常慢）。