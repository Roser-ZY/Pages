---
title: "LRU 改进"
author: "Roser"
date: 2025-05-09
image: "images/content/OS.png"
draft: false
tags:
  - OS
  - Review
draft: true
sr-due: 2025-05-05
sr-interval: 20
sr-ease: 250
---
LRU 改进主要为了解决两个问题：预读失效和缓存污染。
# 预读失效

Linux 系统中，在读取某个页时，由于局部性原理，会读取后面的三个页，以便程序在后续运行时需要用到后面的页，就不再需要从磁盘加载，减少 IO 操作。但是这会导致一个问题，就是如果预加载的页没有被用到，可能会一直在内存中。

LRU 一般采用链表方式，热点页会在表头，而最近最久未使用的页会放在链表尾部。当内存不足时，会优先换出尾部的页。预读页会放在头部，此时一些热点页会被挤到尾部，当下次换出时，热点页在尾部，导致被换出，而不被访问的预读页仍保留在链表中。这就是预读失效。

为了解决这个问题，Linux 采用两个链表，分别为 Active 和 Inactive，分别存储活跃页与不活跃页。优先换出不活跃页的尾部页面。预读页加载后，被添加到 Inactive 链表。

MySQL 也有类似的处理方式，采用 Young 和 Old，Old 在链表尾部，并且两个区域的数量有比例。逻辑和 Active 与 Inactive 基本相同。

> 上面的解决方法其实本质上都是为了既保证热点页的低位，又避免预读页很快被换出。通过分级，很好的解决了这个问题。

# 缓存污染

缓存污染是指，在大批量读取数据时，由于数据被访问过一次，这些数据都会被放到 Active 链表，而原本活跃的页则会被挤出 Active，甚至被挤出内存，换回磁盘。如果这些批量数据后续不再被访问，则会导致缓存污染，因为原本活跃的页有可能需要重新添加到 Active 甚至重新加载。

一般来说，Inactive 的数量是比 Active 数量小的，因此读取大批量数据时，很有可能导致在 Active 的热点页被直接挤出 Inactive 区域，换回磁盘。则后续再访问热点页时，需要重新加载。这个过程会产生大量磁盘 I/O，极大降低系统性能。

这个对于 MySQL 也是一样的原理。不同的是，MySQL 还需要额外判断两次访问的时间间隔。如果时间间隔小于 `1s`（默认值），则不会从 Old 提升到 Young；如果大于 `1s`，则会提升。

> 为什么间隔短反而不提升？因为数据库在数据页中有多条记录，这个数据页会被多次访问到，但是因为顺序扫描，两次访问间隔是很小的（小于 `1s`）。如果不是上面这个多次顺序扫描导致的访问，一般是大于 `1s`，因此认为是正常访问间隔，加入到 Young。
> 
> 这个反直觉的时间间隔主要避免假的多次访问影响热点页的判断。

为了解决热点页被挤出内存的问题，一般采取提升进入 Active 门槛来缓解。目前数据被访问一次就被添加到了 Active，门槛过低。如果设置为访问两次才被提升到 Active，否则只放入 Inactive，则能有效缓解热点页被回收的问题。