---
title: "内存回收"
author: "Roser"
date: 2025-05-09
image: "images/content/OS.png"
draft: false
tags:
  - OS
  - Interview
  - Review
sr-due: 2025-05-13
sr-interval: 18
sr-ease: 230
---
[`malloc()`](malloc()%20内存分配.md) 申请的是虚拟内存，如果程序读写了这块虚拟内存，CPU 就会访问该虚拟内存。如果发现该虚拟内存没有映射到物理内存，CPU 会产生缺页中断，进程从用户态切换到内核态，并将缺页终端交给内核的 Page Fault Handler（缺页中断函数）处理。

缺页中断函数会查看是否有空闲的物理内存，如果有，则直接分配，如果没有，就需要进行内存回收。

> 这里的内存回收是指物理内存回收到虚拟内存（磁盘），而不是内存释放。

内存回收分为后台内存回收（kswapd）和直接内存回收（direct reclaim）。
- 后台内存回收
	物理内存紧张时，会唤醒 `kswapd` 内核线程来回收。这个过程是**异步**的，不会阻塞进程执行。
- 直接内存回收
	如果后台内存回收跟不上进程申请内存的速度，就会进行直接回收。这个过程是同步的，会阻塞进程的执行。

如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，则内核会触发 OOM（Out of Memory）机制。

OOM 会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源。如果内存仍然不足，会继续执行这个步骤，直到释放足够的内存位置。

![](images/内存回收阈值.webp)

上图有三个阈值，将内存划分成四个部分，每个阶段会有不同的内存回收策略。
- 内存充足和内存分配正常阶段，都是正常分配内存。
- 内存压力大阶段，`kswapd` 会进行内存回收，直到剩余内存大于 `pages_high` 为止。
- 内存紧张阶段，会进行直接内存回收，此时进程会被阻塞。

Linux 可以通过修改这几个阈值来控制内存回收的时机。
### OOM 算法

OOM 的计算方式如下：

```cpp
points = process_pages + oom_score_adj * totalpages / 1000;
```

- `points`：打分结果。
- `process_pages`：进程已使用的物理内存页面数。
- `oom_score_adj`：进程的 OOM 校准值。
- `totalpages`：系统总可用页面数。

打分结果越高，进程被 OOM Kill 的几率就越大。可以通过调整 `oom_score_adj`（默认值为 0）来修改进程打分结果。

> `-1000` 可以保证进程不会被 Kill。