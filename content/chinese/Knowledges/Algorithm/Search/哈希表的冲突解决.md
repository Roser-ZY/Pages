---
title: "哈希表的冲突解决"
author: "Roser"
date: 2025-04-01
image: "images/content/Algorithm.png"
draft: false
tags:
  - Algorithm
  - Search
  - Review
sr-due: 2025-04-24
sr-interval: 23
sr-ease: 250
---
[哈希表](哈希表.md)是以空间换时间来加快查找时间复杂度的方法。

哈希表的关键就是[哈希算法](哈希算法.md)（也称为哈希函数）的选择，好的哈希算法应该尽量减少冲突，并且计算速度足够快。但是一般来说，这两者是不可兼得的。

哈希冲突是指，两个不同的 Key 通过哈希函数计算后，会映射到同一个空位。此时必须解决冲突，以便将后添加的元素放到合适的位置，并且能在查找时重新找到。

主要有以下几种方法。
### 链地址法

将哈希表的元素从单一元素改为链表，如果发生冲突，则将冲突的元素添加到链表的末尾。后续查找时，到该链表中通过遍历的方式查找目标元素。

该方法的问题是会增加占用空间，链表内还需要管理节点指针等信息，并且如果冲突较多，则链表遍历（线性）本身会比较耗时。
### 开放寻址法

开放寻址法不引入额外的数据结构，而是通过**多次探测**的方式处理哈希冲突。

探测是指，通过一些方法，以当前冲突的哈希位置为基准，继续在哈希表中查找新的空位，并将冲突元素安置在新空位上。并且需要保证后续能以相同的方式查找到该冲突元素。

开放寻址法**不能随意删除元素**，避免发现空位导致空位之后的其他元素被忽略，造成内存泄漏。一般通过懒删除的方式，在被删除元素的位置记录一个标志，以表示该位置之后可能还有元素。

为了避免标记过多加速性能退化，每次查找记录首个标记位置，并在找到目标元素时，将目标元素与标记位置互换，以便下次查找能更快找到目标元素。

探测方法又分为线性探测，平方探测和多次哈希。
#### 线性探测

线性探测采用**固定步长**的方式进行探测，即发现冲突时，从冲突位置向后进行线性遍历，知道找到空位并将元素放入。

查找时如果发现冲突（即哈希位置与目标元素不相等），也通过线性遍历的方式查找目标值。

线性探测会导致聚集问题。数组中连续被占用的位置越长，这些位置发生冲突的可能性越大（这些位置本来是其他哈希结果应当存放的位置），从而形成恶性循环。
#### 平方探测

平方探测采用**指数步长**的方式进行探测，即每次不再是线性跳过一个固定步数，而是不断指数增加步数。

平方探测能缓解线性探测的聚集效应，并且有助于数据分布更均匀。

但是并没有根本解决聚集现象，且指数步数的增加会导致空间利用率降低，如果发现超出当前哈希表最大长度，可能需要重新分配更大内存，造成资源浪费。
#### 多次哈希

多次哈希也称为再哈希，即使用多个哈希函数，按照固定顺序，对出现的冲突进行再哈希，直到找到空位，或哈希函数用完。

多次哈希能解决聚集问题，但是需要有多个哈希函数，增加计算量，并且极端情况下可能会导致哈希结束仍无法找到空位。