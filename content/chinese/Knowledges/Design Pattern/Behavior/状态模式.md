---
title: "状态模式"
author: "Roser"
date: 2025-05-08
image: "images/content/Design Pattern.png"
draft: false
tags:
  - DesignPattern
  - Review
sr-due: 2025-05-09
sr-interval: 25
sr-ease: 250
---
# 使用场景

状态模式与有限状态机密切相关，当需要进行多个状态转换，并且减少状态间的耦合时可使用该模式。

应当注意，状态模式的状态转换为某个对象（上下文）自身的状态转换，而不是在多个对象（上下文）间进行跳转。后者应当考虑使用[观察者模式](../观察者模式)或[中介者模式](../中介者模式)。

- ? 如果对象需要根据**自身**当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。

- ? 如果某个类需要根据成员变量的当前值改变**自身**行为， 从而需要使用大量的条件语句时， 可使用该模式。

- ? 当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。
# 解决方案

**状态模式**能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。

主要思想是程序在任意时刻仅可处于几种有限的状态中。在任何一个特定状态中，程序的行为都不相同，且可瞬间从一个状态切换到另一个状态。

最简单的状态机可以由条件语句实现。但是这种实现方式会导致后续代码耦合较深，新增状态和修改状态逻辑时很困难。

状态模式建议为所有可能状态新建一个状态类，与状态有关的所有行为都抽象到该类中。原始对象称为**上下文**（Context），它不再通过控制语句实现所有行为，而是保存一个指向当前状态对象的引用，将所有与状态相关的工作**委派**给该状态对象，**该状态对象能够更新上下文的状态对象从而进行状态跳转**。
# 结构


![](images/状态模式类图示意.png)

- **上下文**
	保存了对于一个具体状态对象的引用，并将所有与该状态相关的工作委派给他。上下文通过状态接口与状态对象交互，提供一个设置器（`changeState()`）用于传递新的状态对象。
- **状态接口**
	**声明**特定于状态的方法。这些方法**能被其他所有具体状态所理解**。
- **具体状态**
	**实现**特定于状态的方法。如果某些状态有类似的行为，可以提供一个封装有部分通用行为的中间抽象类。

状态对象可存储对于上下文对象的反向引用，状态可以通过该引用从上下文获取所需信息，并更新上下文的状态以实现状态跳转。

状态模式有一个前提，即所有状态类都必须遵循相同的接口，并且上下文仅通过状态类的接口进行交互。

这个结构看上去和[策略模式](../Behavior/策略模式)很像，但是在状态模式中，特定状态知道所有其他状态的存在，并且能从一个状态转换到另一个状态。而策略模式几乎完全不知道其他策略的存在。
### 优点

- o 遵循单一职责原则，将与特定状态相关的代码放在单独的类中。
- o 遵循开闭原则，无需修改已有状态类和上下文就能引入新状态。
- o 能够有效消除臃肿的条件语句。
### 缺陷

- x 如果状态机只有很少的几个状态，或者很少改变，则状态模式会有些小题大做。

***
看似违反了接口隔离原则（ISP），即一个类不应该依赖它不使用的方法。因为状态模式中一些具体状态只会进行一部分操作，可能有很多用不到的状态需要继承。

但是实际上，上下文依赖抽象状态类，对于使用者来说，这些状态是一样的，即使一些状态看上去不需要某些状态，但是使用者也可以对状态调用一些操作。 

ISP 比较典型的例子应该是，一只老鹰类继承了奔跑函数，这种情况在逻辑上是不合适的。但是状态模式中所有具体类按理说可以执行任何抽象类的操作。

对于用不到的函数，可以在抽象类给出默认实现，即什么都不做或者给出一些日志信息。